Linked Lists
A linked list is another data structure that is like an array in the sense that it stores elements in an ordered sequence. But there are also some key differences.

The main difference is that linked lists are made up of objects called ListNode's. This object contains two attributes:

value - This stores the value of the node. It could be a character, an integer, etc.
next - This stores the reference to the next node in the linked list. The picture below visualizes the ListNode object. This will make more sense a little later on.
By chaining these ListNode objects together we can build a linked list. We start with a ListNode class:

public class ListNode {
    int val;
    ListNode next;

    public ListNode(int val) {
        this.val = val;
        this.next = null;
    }
}
Using the next pointer of each, we can connect the nodes together. Suppose that we have three ListNode objects – ListNode1, ListNode2, ListNode3.
When we instantiate a list node, we don't know where it is stored in memory. The nodes likely won't be contiguous like arrays, but that isn't an issue for linked lists. The visual below gives a glimpse of how the nodes would be stored in memory.
Next, we would need to make sure that our next pointers point to another ListNode, and not null. Only the last node in the linked list would have its next pointer point to null.
ListNode1.next = ListNode2;

The address for ListNode2 is retrieved from memory.
ListNode1’s next pointer points to ListNode2. Next, we set the next pointer for ListNode2 and ListNode3.

ListNode2.next = ListNode3;
ListNode3.next = null;

To traverse a linked list from beginning to end, we can just make use of a simple while loop.


ListNode cur = ListNode1;
while (cur != null) {
    cur = cur.next;
}
We start the traversal at the head of the list, which is ListNode1.
We assign it to a variable cur, denoting the current node we are at.
We execute the while loop until we reach the end of the list which is null.
In each iteration, we update cur to be the next node in the list by setting cur = cur.next.
The traversal runs in
O(n) time where n is the number of nodes in the linked list.
Circular Linked List
An interesting scenario presents itself if ListNode3’s next pointer is set to ListNode1 instead of null. This results in a circular linked list.

Attempting to iterate through a circular linked list would result in an infinite loop. We would never reach the end of the linked list.
Operations of a Singly Linked List
Linked Lists have a head, and a tail pointer. The head pointer points to the very first node in the linked list, ListNode1, and the tail pointer points to the very last node — ListNode3. If there is only one node in the Linked List, the head and the tail point to the same node.

Appending
An advantage that Linked Lists have over arrays is that inserting a new element can be performed in
O(1) time, even if we insert in the middle.

We do not have to shift any elements since there is no requirement for the elements to be stored contiguously in memory.

This assumes we already have a reference to the node at the desired position we want to insert. If we have to traverse the list to arrive at the insertion point, the operation would take
O(n) time.
If we wanted to append a ListNode4 to the end of the list, we would be appending to the tail. Once ListNode4 is appended, we update our tail pointer to be at ListNode4. This operation would be done in
O(1) time since it is only one operation. The steps would look like the following, with code.
tail.next = ListNode4;
tail = ListNode4;
Deleting from a Singly Linked List
Deleting a node from a singly linked list will take
O(1) since we can accomplish this by updating a single pointer.

This assumes we already have a reference to the node at the desired position we want to delete. If we have to traverse the list to arrive at the deletion point, the operation would take
O(n) time.
Suppose we want to delete ListNode2. Currently, our head points to ListNode1, and head.next points to ListNode2. We can update our head.next pointer to ListNode3, which can be accessed by chaining next pointers like head.next.next. This makes sense since head.next is ListNode2, and logically, head.next.next would be ListNode3.
head.next = head.next.next;
Updated linked list after deletion of ListNode2. Notice that now ListNode1’s next pointer points to ListNode3, instead of ListNode2
t can be assumed that the memory occupied by ListNode2 will be cleared via garbage collection in most languages. In other languages like C, you would have to manually free the memory.
